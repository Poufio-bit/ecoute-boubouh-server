// server.js - Serveur WebSocket pour Render.com - VERSION COMPL√àTE AVEC AUDIO + BERNARD_LISTENING
const express = require('express');
const WebSocket = require('ws');
const http = require('http');

const app = express();
const PORT = process.env.PORT || 10000;

// Middleware pour parser JSON
app.use(express.json());

// Cr√©er le serveur HTTP
const server = http.createServer(app);

// √âtat des connexions
const connections = {
    bernard: "disconnected",
    liliann: "disconnected",
    active_sessions: 0
};

// Map pour stocker les WebSockets par client
const clientSockets = new Map();

// Route HTTP pour v√©rifier l'√©tat
app.get('/', (req, res) => {
    res.json({
        service: "Ecoute Boubouh Server",
        version: "2.1.0 - Audio Support + Bernard Listening",
        status: "running",
        connections: connections,
        features: ["identification", "audio_streaming", "real_time_communication", "bernard_listening"],
        timestamp: new Date().toISOString()
    });
});

// Route de sant√© pour Render
app.get('/health', (req, res) => {
    res.status(200).json({ status: "healthy" });
});

// Cr√©er le serveur WebSocket sur le M√äME port que HTTP
const wss = new WebSocket.Server({ 
    server: server,
    path: '/'
});

console.log('üöÄ Serveur WebSocket configur√© sur le m√™me port que HTTP');

// Fonction pour mettre √† jour les statistiques
function updateStats() {
    connections.active_sessions = clientSockets.size;
    console.log('üìä Stats mises √† jour:', connections);
}

// FONCTION: G√©rer les donn√©es audio
function handleAudioData(data, fromClient) {
    console.log(`üéµ Traitement audio de ${fromClient}`);
    
    const { from, to, data: audioData, sampleRate, format, channels } = data;
    
    // Validation des donn√©es
    if (!audioData || audioData.length === 0) {
        console.error('‚ùå Donn√©es audio vides');
        return;
    }
    
    if (!to || (to !== 'bernard' && to !== 'liliann')) {
        console.error(`‚ùå Destinataire invalide: ${to}`);
        return;
    }
    
    // V√©rifier que l'exp√©diteur correspond au client connect√©
    if (from !== fromClient) {
        console.error(`‚ùå Exp√©diteur incoh√©rent: ${from} vs ${fromClient}`);
        return;
    }
    
    console.log(`üéµ Audio de ${from} vers ${to} - Taille: ${audioData.length} caract√®res`);
    
    // Pr√©parer le message audio pour le destinataire
    const audioMessage = {
        type: 'audio_data',
        from: from,
        to: to,
        data: audioData,
        sampleRate: sampleRate || 44100,
        format: format || 'PCM_16BIT',
        channels: channels || 1,
        timestamp: new Date().toISOString()
    };
    
    // Envoyer l'audio au destinataire
    const targetSocket = clientSockets.get(to);
    if (targetSocket && targetSocket.readyState === WebSocket.OPEN) {
        try {
            targetSocket.send(JSON.stringify(audioMessage));
            console.log(`‚úÖ Audio transf√©r√© de ${from} vers ${to}`);
        } catch (error) {
            console.error(`‚ùå Erreur envoi audio vers ${to}:`, error.message);
        }
    } else {
        console.log(`‚ö†Ô∏è ${to} non connect√© - audio ignor√©`);
        
        // Informer l'exp√©diteur que le destinataire n'est pas disponible
        const notificationMessage = {
            type: 'delivery_failed',
            target: to,
            reason: 'Client non connect√©',
            timestamp: new Date().toISOString()
        };
        
        const senderSocket = clientSockets.get(fromClient);
        if (senderSocket && senderSocket.readyState === WebSocket.OPEN) {
            try {
                senderSocket.send(JSON.stringify(notificationMessage));
            } catch (error) {
                console.error(`‚ùå Erreur notification vers ${fromClient}:`, error.message);
            }
        }
    }
}

// FONCTION: Broadcaster le statut des utilisateurs
function broadcastUserStatus() {
    const userStatusMessage = {
        type: "user_status",
        users: {
            bernard: connections.bernard,
            liliann: connections.liliann
        },
        timestamp: new Date().toISOString()
    };
    
    clientSockets.forEach((socket, name) => {
        if (socket.readyState === WebSocket.OPEN) {
            try {
                socket.send(JSON.stringify(userStatusMessage));
            } catch (error) {
                console.error(`‚ùå Erreur broadcast status vers ${name}:`, error.message);
            }
        }
    });
}

// Gestion des connexions WebSocket
wss.on('connection', (ws, req) => {
    console.log('üì± Nouvelle connexion WebSocket');
    console.log('üîç IP:', req.socket.remoteAddress);
    console.log('üîç User-Agent:', req.headers['user-agent']);
    
    let clientName = null;
    let connectionId = `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Envoyer un message de bienvenue
    ws.send(JSON.stringify({
        type: "welcome",
        message: "Connexion WebSocket √©tablie! Envoyez 'bernard' ou 'liliann' pour vous identifier.",
        server: "Ecoute Boubouh Server v2.1",
        features: ["audio_streaming", "real_time_communication", "bernard_listening"],
        connectionId: connectionId,
        timestamp: new Date().toISOString()
    }));
    
    ws.on('message', (message) => {
        const messageStr = message.toString();
        console.log('üì• Message re√ßu:', messageStr.length > 100 ? messageStr.substring(0, 100) + '...' : messageStr);
        console.log('üì• De:', clientName || 'non-identifi√©');
        
        // Essayer de parser en JSON d'abord
        try {
            const data = JSON.parse(messageStr);
            console.log('üìÑ JSON pars√© - Type:', data.type);
            
            // NOUVEAU: G√©rer bernard_listening
            if (data.type === "bernard_listening") {
                const listening = data.listening;
                console.log(`üéß Bernard listening: ${listening}`);
                
                // Envoyer le message √† Liliann
                const liliannSocket = clientSockets.get("liliann");
                if (liliannSocket && liliannSocket.readyState === WebSocket.OPEN) {
                    try {
                        liliannSocket.send(JSON.stringify({
                            type: "bernard_listening",
                            listening: listening,
                            from: "bernard",
                            timestamp: new Date().toISOString()
                        }));
                        console.log(`‚úÖ Message listening envoy√© √† Liliann: ${listening}`);
                    } catch (error) {
                        console.error(`‚ùå Erreur envoi vers Liliann:`, error.message);
                    }
                } else {
                    console.log(`‚ö†Ô∏è Liliann non connect√©e`);
                }
                return;
            }
            
            // G√©rer les diff√©rents types de messages
            if (data.type === "audio_data") {
                // Traitement des donn√©es audio
                if (clientName) {
                    handleAudioData(data, clientName);
                } else {
                    console.error('‚ùå Tentative d\'envoi audio sans identification');
                    ws.send(JSON.stringify({
                        type: "error",
                        message: "Vous devez d'abord vous identifier avant d'envoyer de l'audio",
                        timestamp: new Date().toISOString()
                    }));
                }
                return; // Sortir ici pour √©viter le traitement d'identification
            } else if (data.type === "ping") {
                // R√©pondre aux pings
                ws.send(JSON.stringify({
                    type: "pong",
                    timestamp: new Date().toISOString()
                }));
                return;
            } else if (data.type === "status_request") {
                // Envoyer le statut des utilisateurs
                ws.send(JSON.stringify({
                    type: "user_status",
                    users: {
                        bernard: connections.bernard,
                        liliann: connections.liliann
                    },
                    timestamp: new Date().toISOString()
                }));
                return;
            }
            
            // Traitement de l'identification
            if (data.type === "connect" && data.user) {
                clientName = data.user;
            } else if (data.action === "identify" && data.device) {
                clientName = data.device;
            } else if (data.type === "identify" && data.role) {
                clientName = data.role;
            }
        } catch (e) {
            // Si ce n'est pas du JSON, peut-√™tre juste le nom
            console.log('üìÑ Message texte simple:', messageStr);
            if (messageStr === "bernard" || messageStr === "liliann") {
                clientName = messageStr;
            }
        }
        
        // Si on a identifi√© un client valide
        if (clientName && (clientName === "bernard" || clientName === "liliann")) {
            console.log(`‚úÖ Client identifi√©: ${clientName}`);
            
            // D√©connecter l'ancien client s'il existe
            if (clientSockets.has(clientName)) {
                const oldSocket = clientSockets.get(clientName);
                if (oldSocket !== ws && oldSocket.readyState === WebSocket.OPEN) {
                    oldSocket.send(JSON.stringify({
                        type: "disconnected",
                        reason: "Nouvelle connexion du m√™me client",
                        timestamp: new Date().toISOString()
                    }));
                    oldSocket.close();
                }
            }
            
            // Enregistrer le nouveau client
            clientSockets.set(clientName, ws);
            connections[clientName] = "connected";
            updateStats();
            
            // Confirmer la connexion
            const confirmationMessage = {
                type: "connection_confirmed",
                client: clientName,
                status: "connected",
                message: `Bonjour ${clientName}! Connexion r√©ussie. Audio streaming + bernard_listening disponibles.`,
                connectionId: connectionId,
                timestamp: new Date().toISOString()
            };
            
            ws.send(JSON.stringify(confirmationMessage));
            console.log('‚úÖ Confirmation envoy√©e √†', clientName);
            
            // Broadcaster le statut des utilisateurs √† tous les clients
            broadcastUserStatus();
            
        } else if (clientName) {
            // Le client est d√©j√† identifi√©, traiter d'autres messages
            console.log(`üì® Message de ${clientName}:`, messageStr.substring(0, 50) + '...');
            
        } else {
            // Message de debug pour comprendre ce qui arrive
            const debugMessage = {
                type: "debug",
                received: messageStr.substring(0, 100),
                message: "Message re√ßu mais format non reconnu. Essayez 'bernard' ou 'liliann'",
                expectedFormats: [
                    "bernard",
                    "liliann", 
                    '{"type":"connect","user":"bernard"}',
                    '{"action":"identify","device":"bernard"}'
                ],
                timestamp: new Date().toISOString()
            };
            
            ws.send(JSON.stringify(debugMessage));
            console.log('üêõ Message de debug envoy√©');
        }
    });
    
    ws.on('close', (code, reason) => {
        console.log(`üëã Connexion ferm√©e pour: ${clientName || 'non-identifi√©'}`);
        console.log(`üëã Code: ${code}, Raison: ${reason}`);
        
        if (clientName && clientSockets.get(clientName) === ws) {
            clientSockets.delete(clientName);
            connections[clientName] = "disconnected";
            updateStats();
            console.log(`üîå ${clientName} marqu√© comme d√©connect√©`);
            
            // Broadcaster le nouveau statut
            broadcastUserStatus();
        }
    });
    
    ws.on('error', (error) => {
        console.error('‚ùå Erreur WebSocket:', error);
        if (clientName && clientSockets.get(clientName) === ws) {
            clientSockets.delete(clientName);
            connections[clientName] = "disconnected";
            updateStats();
            broadcastUserStatus();
        }
    });
    
    // Ping p√©riodique pour maintenir la connexion
    const pingInterval = setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
            ws.ping();
        } else {
            clearInterval(pingInterval);
        }
    }, 30000); // Ping toutes les 30 secondes
});

// Nettoyage p√©riodique des connexions ferm√©es
setInterval(() => {
    let cleanupNeeded = false;
    
    clientSockets.forEach((socket, clientName) => {
        if (socket.readyState !== WebSocket.OPEN) {
            console.log(`üßπ Nettoyage connexion ferm√©e: ${clientName}`);
            clientSockets.delete(clientName);
            connections[clientName] = "disconnected";
            cleanupNeeded = true;
        }
    });
    
    if (cleanupNeeded) {
        updateStats();
        broadcastUserStatus();
    }
}, 60000); // V√©rification toutes les minutes

// Ping serveur p√©riodique pour tous les clients
setInterval(() => {
    const serverPingMessage = {
        type: "server_ping",
        timestamp: new Date().toISOString()
    };
    
    clientSockets.forEach((socket, clientName) => {
        if (socket.readyState === WebSocket.OPEN) {
            try {
                socket.send(JSON.stringify(serverPingMessage));
            } catch (error) {
                console.error(`‚ùå Erreur ping vers ${clientName}:`, error.message);
            }
        }
    });
}, 25000); // Ping toutes les 25 secondes (sync avec l'app Android)

// D√©marrer le serveur
server.listen(PORT, () => {
    console.log(`üåê Serveur d√©marr√© sur le port ${PORT}`);
    console.log(`üì° HTTP: http://localhost:${PORT}`);
    console.log(`üîå WebSocket: ws://localhost:${PORT}`);
    console.log('‚úÖ WebSocket et HTTP sur le M√äME port (requis par Render)');
    console.log('üìã Clients support√©s: bernard, liliann');
    console.log('üéµ Fonctionnalit√©s: identification + streaming audio temps r√©el + bernard_listening');
});

// Gestion propre de l'arr√™t
process.on('SIGTERM', () => {
    console.log('üõë Arr√™t du serveur...');
    
    // Fermer toutes les connexions WebSocket proprement
    clientSockets.forEach((socket, clientName) => {
        try {
            socket.send(JSON.stringify({
                type: "server_shutdown",
                message: "Serveur en cours d'arr√™t",
                timestamp: new Date().toISOString()
            }));
            socket.close(1001, 'Serveur en cours d\'arr√™t');
        } catch (error) {
            console.error(`‚ùå Erreur fermeture ${clientName}:`, error.message);
        }
    });
    
    server.close(() => {
        console.log('‚úÖ Serveur arr√™t√© proprement');
        process.exit(0);
    });
});

process.on('SIGINT', () => {
    console.log('\nüõë Interruption re√ßue - Arr√™t du serveur...');
    process.emit('SIGTERM');
});

// Logging des statistiques p√©riodiques
setInterval(() => {
    const connectedClients = Array.from(clientSockets.keys());
    console.log(`üìä Clients connect√©s: [${connectedClients.join(', ')}] - Total: ${connectedClients.length}`);
}, 300000); // Toutes les 5 minutes
